## basicAlgorithm
自己练习算法
### 排序算法
**稳定性**    
    如果Ai = Aj，排序前Ai在Aj之前，排序后Ai还在Aj之前，则称这种排序算法是稳定的。通俗地讲就是保证排序前后两个相等的数的相对顺序不变。
需要注意的是，排序算法是否为稳定的是由具体算法决定的，不稳定的算法在某种条件下可以变为稳定的算法，而稳定的算法在某种条件下也可以变为不稳定的算法。
例如，对于冒泡排序，原本是稳定的排序算法，如果将记录交换的条件改成A[i] >= A[i + 1]，则两个相等的记录就会交换位置，从而变成不稳定的排序算法。

**好处:**
    排序算法如果是稳定的，那么从一个键上排序，然后再从另一个键上排序，第一个键排序的结果可以为第二个键排序所用。基数排序就是这样，先按低位排序，逐次按高位排序，低位排序后元素的顺序在高位也相同时是不会改变的。
 
#### 冒泡排序法

    算法的名字由来是因为越小(或越大)的元素会经由交换慢慢“浮”到数列的顶端。
  
**步骤** :（默认升序排列）  
    1. 比较相邻的元素，如果后一个比前一个严格大，换序。  
    2. 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。此轮结束后，最后一个位置存放的是当前最大。  
    3. 针对所有的元素重复以上的步骤。  
    4. 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。  
    
**改进**  
1.如果数列本身是升序排列，设置一个flag，在第一次遍历的时候判断。如果没有发生一次换序，说明原序列是已经排好序的，直接退出;  
2.如果前10个是无序，后90已经排好顺序了。设置一个flag，初始等于最大长度。记录每次发生的最大交换角标。这样就不需要对后面多余排序部分进行排序。

![](http://images2015.cnblogs.com/blog/739525/201603/739525-20160329100443676-1647340243.gif)

#### 选择排序（Seliction sort）  

选择排序也是一种简单直观的排序算法。它的工作原理很容易理解：初始时在序列中找到最小（大）元素，放到序列的起始位置作为已排序序列；然后，再从剩余
未排序元素中继续寻找最小（大）元素，放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。


注意选择排序与冒泡排序的区别：冒泡排序通过依次交换相邻两个顺序不合法的元素位置，从而将当前最小（大）元素放到合适的位置；而选择排序每遍历一次都记住了当前最小（大）元素的位置，最后仅需一次交换操作即可将其放到合适的位置。
    
 ![](http://images2015.cnblogs.com/blog/739525/201603/739525-20160329102006082-273282321.gif)
 
 ![](http://images2015.cnblogs.com/blog/739525/201603/739525-20160328195305723-701227998.gif)
 
 
 **注意**
 选择排序是不稳定算法，不稳定发生在最小元素与A[i]交换的时刻。    
 比如序列：{ 5, 8, 5, 2, 9 }，一次选择的最小元素是2，然后把2和第一个5进行交换。5和5的相对顺序发生了改变
 
 #### 插入排序(Insertion Sort)  
 
 对于未排序数据(右手抓到的牌)，在已排序序列(左手已经排好序的手牌)中从后向前扫描，找到相应位置并插入。
    
**步骤**  
具体算法描述如下：

1. 从第一个 _x_ 元素开始，该元素可以认为已经被排序
2. 取出下一个 _xnext_ 元素，在已经排序的元素序列中从后向前扫描
3. 如果 _x_ 大于 _xnext_ ，将 _x_ 元素移到后一位置
4. 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置
5. 将新元素插入到该位置后
6. 重复步骤2~5

![](http://images2015.cnblogs.com/blog/739525/201603/739525-20160329095145504-1018443290.gif)
![](http://images2015.cnblogs.com/blog/739525/201603/739525-20160328201132394-577931661.gif)

**特点**  

插入排序不适合对于数据量比较大的排序应用。但是，如果需要排序的数据量很小，比如量级小于千，那么插入排序还是一个不错的选择。 插入排序在工业级库中也有着广泛的应用，在STL的sort算法和stdlib的qsort算法中，都将插入排序作为快速排序的补充，用于少量元素的排序（通常为8个或以下）。

#### 希尔排序(Shell Sort)

希尔排序，也叫递减增量排序，是插入排序的一种更高效的改进版本。希尔排序是不稳定的排序算法。   

###### 希尔排序是基于插入排序的以下两点性质而提出改进方法的：

>1. 插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率
>2. 但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位

希尔排序通过将比较的全部元素分为几个区域来提升插入排序的性能。这样可以让一个元素可以一次性地朝最终位置前进一大步。然后算法再取越来越小的步长进行排序，算法的最后一步就是普通的插入排序，但是到了这步，需排序的数据几乎是已排好的了（此时插入排序较快）。  
假设有一个很小的数据在一个已按升序排好序的数组的末端。如果用复杂度为O(n^2)的排序（冒泡排序或直接插入排序），可能会进行n次的比较和交换才能将该数据移至正确位置。而希尔排序会用较大的步长移动数据，所以小数据只需进行少数比较和交换即可到正确位置。
 **稳定性**  
  希尔排序是**不稳定**的排序算法，虽然一次插入排序是稳定的，不会改变相同元素的相对顺序，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱。

#### 归并排序  

归并排序是创建在归并操作上的一种有效的排序算法，效率为O(nlogn)，1945年由冯·诺伊曼首次提出。

归并排序的实现分为递归实现与非递归(迭代)实现。递归实现的归并排序是算法设计中分治策略的典型应用，我们将一个大问题分割成小问题分别解决，然后用所有小问题的答案来解决整个大问题。非递归(迭代)实现的归并排序首先进行是两两归并，然后四四归并，然后是八八归并，一直下去直到归并了整个数组。

归并排序算法主要依赖归并(Merge)操作。归并操作指的是将两个已经排序的序列合并成一个序列的操作，归并操作步骤如下：

>1. 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列
>2. 设定两个指针，最初位置分别为两个已经排序序列的起始位置
>3. 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置
>4. 重复步骤3直到某一指针到达序列尾
>5. 将另一序列剩下的所有元素直接复制到合并序列尾

![](http://images2015.cnblogs.com/blog/739525/201603/739525-20160328211743473-909317024.gif)
![](http://images2015.cnblogs.com/blog/739525/201603/739525-20160328211504519-1388466622.gif)

**应用**  

归并排序除了可以对数组进行排序，还可以高效的求出数组小和（即单调和）以及数组中的逆序对

#### 堆排序(Heap Sort)  
    
堆排序是指利用堆这种数据结构所设计的一种选择排序算法。堆是一种近似完全二叉树的结构（通常堆是通过一维数组来实现的），并满足性质：以最大堆（也叫大根堆、大顶堆）为例，其中父结点的值总是大于它的孩子节点。

我们可以很容易的定义堆排序的过程：

>1. 由输入的无序数组构造一个最大堆，作为初始的无序区
>2. 把堆顶元素（最大值）和堆尾元素互换
>3. 把堆（无序区）的尺寸缩小1，并调用heapify(A, 0)从新的堆顶元素开始进行堆调整》
>4. 重复步骤2，直到堆的尺寸为1

![](http://images2015.cnblogs.com/blog/739525/201603/739525-20160328213839160-2037856208.gif)

**稳定性**  

堆排序是不稳定的排序算法，不稳定发生在堆顶元素与A[i]交换的时刻。  比如序列：{ 9, 5, 7, 5 }，堆顶元素是9，堆排序下一步将9和第二个5进行交换，得到序列 { 5, 5, 7, 9 }，再进行堆调整得到{ 7, 5, 5, 9 }，重复之前的操作最后得到{ 5, 5, 7, 9 }从而改变了两个5的相对次序。

#### 快速排序(Quick Sort)

  快速排序是由东尼·霍尔所发展的一种排序算法。在平均状况下，排序n个元素要O(nlogn)次比较。在最坏状况下则需要O(n^2)次比较，但这种状况并不常见。事实上，快速排序通常明显比其他O(nlogn)算法更快，因为它的内部循环可以在大部分的架构上很有效率地被实现出来。

快速排序使用分治策略(Divide and Conquer)来把一个序列分为两个子序列。  步骤为：

>1. 从序列中挑出一个元素，作为"基准"(pivot).
>2. 把所有比基准值小的元素放在基准前面，所有比基准值大的元素放在基准的后面（相同的数可以到任一边），这个称为分区(partition)操作。
>3. 对每个分区递归地进行步骤1~2，递归的结束条件是序列的大小是0或1，这时整体已经被排好序了。

![](http://images2015.cnblogs.com/blog/739525/201603/739525-20160328215109269-23458370.gif)

**稳定性**  
  比如序列：{ 1, 3, 4, 2, 8, 9, 8, 7, 5 }，基准元素是5，一次划分操作后5要和第一个8进行交换，从而改变了两个元素8的相对次序。

